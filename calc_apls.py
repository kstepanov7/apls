# -*- coding: utf-8 -*-
"""calc_apls.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1__sNn7oR_UFyJLALcN3AikUqEWijSuiy
"""

import cv2
import numpy as np
import pandas as pd
import sknw
from sknw.sknw import build_sknw
from scipy import ndimage
from scipy.ndimage import binary_dilation
from shapely.geometry import LineString, Point
from simplification.cutil import simplify_coords
from skimage.filters import gaussian
from skimage.morphology import remove_small_objects, skeletonize

from apls.apls.apls import execute, gather_files, _clean_sub_graphs
import pandas as pd
import ntpath
import os, sys


def remove_duplicates(lines):
    all_paths = set()
    new_lines = []
    for l, line in enumerate(lines):
        points = line.coords
        for i in range(1, len(points)):
            pt1 = (int(points[i - 1][0]), int(points[i - 1][1]))
            pt2 = (int(points[i][0]), int(points[i][1]))
            if (pt1, pt2) not in all_paths and (pt2, pt1) not in all_paths and not pt1 == pt2:
                new_lines.append(LineString((pt1, pt2)))
                all_paths.add((pt1, pt2))
                all_paths.add((pt2, pt1))
    return new_lines


def filter_lines(new_lines, node_count):
    filtered_lines = []
    for line in new_lines:
        points = line.coords
        pt1 = (int(points[0][0]), int(points[0][1]))
        pt2 = (int(points[1][0]), int(points[1][1]))

        length = np.math.hypot(pt1[0] - pt2[0], pt1[1] - pt2[1])

        if not ((node_count[pt1] == 1 and node_count[pt2] > 2  or node_count[pt2] == 1 and node_count[pt1] > 2) and length < 10):
            filtered_lines.append(line)
    return filtered_lines


def calculate_node_count(new_lines):
    node_count = {}
    for l, line in enumerate(new_lines):
        points = line.coords
        for i in range(1, len(points)):
            pt1 = (int(points[i - 1][0]), int(points[i - 1][1]))
            pt2 = (int(points[i][0]), int(points[i][1]))
            pt1c = node_count.get(pt1, 0)
            pt1c += 1
            node_count[pt1] = pt1c
            pt2c = node_count.get(pt2, 0)
            pt2c += 1
            node_count[pt2] = pt2c
    return node_count

def split_line(line):
    all_lines = []
    points = line.coords
    pt1 = (int(points[0][0]), int(points[0][1]))
    pt2 = (int(points[1][0]), int(points[1][1]))
    dist = np.math.hypot(pt1[0] - pt2[0], pt1[1] - pt2[1])
    if dist > 10:
        new_lines = cut(line, 5)
        for l in new_lines:
            for sl in split_line(l):
                all_lines.append(sl)
    else:
        all_lines.append(line)
    return all_lines


def cut(line, distance):
    # Cuts a line in two at a distance from its starting point
    # This is taken from shapely manual
    if distance <= 0.0 or distance >= line.length:
        return [LineString(line)]
    coords = list(line.coords)
    for i, p in enumerate(coords):
        pd = line.project(Point(p))
        if pd == distance:
            return [
                LineString(coords[:i+1]),
                LineString(coords[i:])]
        if pd > distance:
            cp = line.interpolate(distance)
            return [
                LineString(coords[:i] + [(cp.x, cp.y)]),
                LineString([(cp.x, cp.y)] + coords[i:])]


def to_line_strings(mask, sigma=2, threashold=0.51, small_obj_size=0, dilation=0):
    mask = gaussian(mask, sigma=sigma)
    #mask = mask[..., 0]
    mask[mask < threashold] = 0
    mask[mask >= threashold] = 1
    mask = np.array(mask, dtype=np.uint8)
    #mask = mask[:1300, :1300]
    mask = cv2.copyMakeBorder(mask, 8, 8, 8, 8, cv2.BORDER_REPLICATE)
    if dilation > 0:
        mask = binary_dilation(mask, iterations=dilation)
    #mask, _ = ndimage.label(mask)
    if small_obj_size > 0:
        mask = remove_small_objects(mask, small_obj_size)
    mask[mask > 0] = 1

    ske = skeletonize(mask).astype(np.uint16)
    graph = sknw.sknw.build_sknw(ske, multi=True)

    line_strings = []
    lines = []
    all_coords = []
    nodes = graph.nodes()
    # draw edges by pts
    for (s, e) in graph.edges():
        for k in range(len(graph[s][e])):
            ps = graph[s][e][k]['pts']
            coords = []
            start = (int(nodes[s]['o'][1]), int(nodes[s]['o'][0]))
            all_points = set()

            for i in range(1, len(ps)):
                pt1 = (int(ps[i - 1][1]), int(ps[i - 1][0]))
                pt2 = (int(ps[i][1]), int(ps[i][0]))
                if pt1 not in all_points and pt2 not in all_points:
                    coords.append(pt1)
                    all_points.add(pt1)
                    coords.append(pt2)
                    all_points.add(pt2)
            end = (int(nodes[e]['o'][1]), int(nodes[e]['o'][0]))

            same_order = True
            if len(coords) > 1:
                same_order = np.math.hypot(start[0] - coords[0][0], start[1] - coords[0][1]) <= np.math.hypot(end[0] - coords[0][0], end[1] - coords[0][1])
            if same_order:
                coords.insert(0, start)
                coords.append(end)
            else:
                coords.insert(0, end)
                coords.append(start)
            coords = simplify_coords(coords, 2.0)
            all_coords.append(coords)

    for coords in all_coords:
        if len(coords) > 0:
            line_obj = LineString(coords)
            lines.append(line_obj)
            line_string_wkt = line_obj.wkt
            line_strings.append(line_string_wkt)
    new_lines = remove_duplicates(lines)
    new_lines = filter_lines(new_lines, calculate_node_count(new_lines))
    line_strings = [ l.wkt for l in new_lines]
    return line_strings


def prepare_input(gt_mask, prop_mask, img_id='ID', sigma=2):
    '''
    Converts to wkt format gt and proposal masks
    Input:
        gt_mask - np.array with gt mask
        prop_mask - np.array with proposal mask
    Output:
        df_gt - pd.DataFrame with gt wkt
        df_prop - pd.DataFrame with prop wkt
    '''


    gt_ls = to_line_strings(gt_mask, sigma=sigma)
    prop_ls = to_line_strings(prop_mask, sigma=sigma)

    data = []
    for i in range(len(gt_ls)):
          data.append([img_id, gt_ls[i]])
    df_gt = pd.DataFrame(data, columns=['ImageId', 'WKT_Pix'])

    data = []
    for i in range(len(prop_ls)):
          data.append([img_id, prop_ls[i]])
    df_prop = pd.DataFrame(data, columns=['ImageId', 'WKT_Pix'])

    return df_gt, df_prop

class HiddenPrints:
    def __enter__(self):
        self._original_stdout = sys.stdout
        sys.stdout = open(os.devnull, 'w')

    def __exit__(self, exc_type, exc_val, exc_tb):
        sys.stdout.close()
        sys.stdout = self._original_stdout


def calc_apls(mask_gt, mask_p, img_dir, max_snap=4,
              max_nodes=500, min_path_length=10, apls_only=True):
    '''
    Calculates apls and some other metrics
    Input:
        mask_gt (np.array) - gt mask
        mask_p (np.array) - proposal mask
        img_dir (srt) - path to image in .tif format
        apls_only (bool) - if True, then only apls will be calculated
                           if False -  apls, topo and sp metrics will be caculated,
                                       also banch of plots will be saved to outputs directory
    '''

    img_id = ntpath.basename(img_dir)
    img_id = img_id[:img_id.find('.tif')]
    df_gt, df_prop = prepare_input(mask_gt, mask_p, img_id=img_id)

    with HiddenPrints():
        gt_list, gp_list, root_list, im_loc_list = gather_files('gt_wkt_prop_wkt', '/', '/',
                                                  im_dir=img_dir,
                                                  im_prefix='',
                                                  gt_wkt_file=df_gt, 
                                                  prop_wkt_file=df_prop,
                                                  max_files=1000)
        
        score = execute(img_id, gt_list, gp_list, root_list, im_loc_list, test_method="gt_wkt_prop_wkt", verbose=False, 
                        max_snap_dist=max_snap, max_nodes=max_nodes, min_path_length=min_path_length, apls_only=apls_only)
        return score
